<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeVerse</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #f5f5f5;
        }
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="600" height="400"></canvas>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Local player data
        let player = { x: 100, y: 100, size: 30, color: 'green' };
        const players = {}; // Other players data

        // Movement variables
        const speed = 5;
        let velocityX = 0;
        let velocityY = 0;
        const keysPressed = { w: false, a: false, s: false, d: false };

        // Update velocity based on keys pressed
        function updateVelocity() {
            velocityX = 0;
            velocityY = 0;
            if (keysPressed['w']) velocityY -= speed;
            if (keysPressed['s']) velocityY += speed;
            if (keysPressed['a']) velocityX -= speed;
            if (keysPressed['d']) velocityX += speed;
        }

        // Handle keydown and keyup for smoother diagonal movement
        window.addEventListener('keydown', (e) => {
            if (e.key in keysPressed) {
                keysPressed[e.key] = true;
                updateVelocity();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key in keysPressed) {
                keysPressed[e.key] = false;
                updateVelocity();
            }
        });

        // Render function for the game loop
        function render() {
            // Update position with smooth interpolation
            player.x += velocityX;
            player.y += velocityY;

            // Send updated position to server
            socket.emit('playerMovement', { x: player.x, y: player.y });

            // Clear canvas and draw the local player
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.size, player.size);

            // Draw other players with interpolation
            for (const id in players) {
                const p = players[id];
                if (id !== socket.id) { // Don't render your own player (green)
                    // Interpolate position towards target position
                    p.x += (p.targetX - p.x) * 0.1; // Adjust the 0.1 for smoother/faster interpolation
                    p.y += (p.targetY - p.y) * 0.1;

                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                }
            }

            requestAnimationFrame(render);
        }

        // Sync with server data
        socket.on('currentPlayers', (data) => {
            // Merge the current players with the new ones
            Object.assign(players, data);
            for (const id in players) {
                players[id].targetX = players[id].x;
                players[id].targetY = players[id].y;
            }
        });

        socket.on('newPlayer', (data) => {
            players[data.id] = { x: data.x, y: data.y, targetX: data.x, targetY: data.y, size: 30, color: 'blue' }; // Add new player
        });

        socket.on('playerMoved', (data) => {
            if (players[data.id]) {
                // Set target positions instead of immediate positions
                players[data.id].targetX = data.x;
                players[data.id].targetY = data.y;
            }
        });

        socket.on('removePlayer', (id) => {
            delete players[id]; // Remove disconnected player
        });

        // Initialize rendering loop
        render();
    </script>
</body>
</html>
