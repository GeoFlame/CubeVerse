<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeVerse</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #f5f5f5; }
        canvas { border: 1px solid black; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const player = { x: 100, y: 100, size: 30, color: 'green', health: 100, rotation: 0 };
        const players = {}; // Other players
        const bullets = []; // Bullets array (from server)
        const speed = 3;
        let velocityX = 0, velocityY = 0;
        const keysPressed = { w: false, a: false, s: false, d: false };

        function updateVelocity() {
            velocityX = 0; velocityY = 0;
            if (keysPressed['w']) velocityY -= speed;
            if (keysPressed['s']) velocityY += speed;
            if (keysPressed['a']) velocityX -= speed;
            if (keysPressed['d']) velocityX += speed;
        }

        // Rotation to face mouse
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            player.rotation = Math.atan2(mouseY - player.y, mouseX - player.x);
        });

        // Movement controls
        window.addEventListener('keydown', (e) => { if (e.key in keysPressed) { keysPressed[e.key] = true; updateVelocity(); } });
        window.addEventListener('keyup', (e) => { if (e.key in keysPressed) { keysPressed[e.key] = false; updateVelocity(); } });

        // Fire bullet
        window.addEventListener('click', () => {
            socket.emit('shootBullet', { x: player.x, y: player.y, angle: player.rotation });
        });

        function randomSpawn() {
            player.x = Math.random() * (canvas.width - player.size);
            player.y = Math.random() * (canvas.height - player.size);
        }
        randomSpawn();

        // Send movement data to the server
        function movePlayer() {
            socket.emit('playerMovement', { velocityX, velocityY, rotation: player.rotation });
        }

        setInterval(movePlayer, 16);

        // Render game loop
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.save();
            ctx.translate(player.x + player.size / 2, player.y + player.size / 2);
            ctx.rotate(player.rotation);
            ctx.fillStyle = player.color;
            ctx.fillRect(-player.size / 2, -player.size / 2, player.size, player.size);
            ctx.restore();

            // Draw health bar
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y - 10, player.size, 5);
            ctx.fillStyle = 'green';
            ctx.fillRect(player.x, player.y - 10, player.size * (player.health / 100), 5);

            // Draw other players
            for (const id in players) {
                const p = players[id];
                ctx.save();
                ctx.translate(p.x + p.size / 2, p.y + p.size / 2);
                ctx.rotate(p.rotation);
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                ctx.restore();

                // Draw health bar
                ctx.fillStyle = 'red';
                ctx.fillRect(p.x, p.y - 10, p.size, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(p.x, p.y - 10, p.size * (p.health / 100), 5);
            }

            // Draw bullets
            bullets.forEach(bullet => {
                ctx.fillStyle = 'black';
                ctx.fillRect(bullet.x, bullet.y, bullet.size, bullet.size);
            });

            requestAnimationFrame(render);
        }

        // Update game state from the server
        socket.on('updateGameState', (data) => {
            Object.assign(players, data.players);
            player.health = data.player.health;
            bullets.length = 0;
            bullets.push(...data.bullets);
        });

        render();
    </script>
</body>
</html>
